/*
   Library in grol for discord bot.
*/

// --- General library functions ---

// Note: some of these could be moved from recursive to iterative now that we have `for` loops.

// f argument takes the element and the index
func walk(f, a) {
	(f,a,i) => {
		if (len(a)==0) {
			[]
		} else {
			[f(first(a),i)]+self(f,rest(a),i+1)
		}
	}(f,a,0)
}

// Convert to string
func str(x) {sprintf("%v", x)}

// Apply a function to each element of an array.
func apply(f, a) {
    if (len(a)==0) {
        []
    } else {
        [f(first(a))]+apply(f,rest(a))
    }
}

// Reverse an array or map or string
func reverse(a) {
    if len(a) == 0 {
        return []
    }
    self(rest(a)) + first(a)
}

// Filter an array
func filter(predicate, arr) {
	if len(arr) == 0 {
	  []
	} else if predicate(first(arr)) {
      [first(arr)] + filter(predicate, rest(arr))
	} else {
	  filter(predicate, rest(arr))
	}
}


// ---- discord specific ----

discord = {
  "actionRow": elems => {
		{
		"type": 1,
		"components": elems
		}
	},
  "button": (label, style, custom_id) => {
		{
			"type": 2,
			"label": label,
			"style": style,
			"custom_id": custom_id
		}
	},
  "buttonStyle" : {
		"primary": 1,
		"secondary": 2,
		"success": 3,
		"danger": 4,
		"link": 5
	},
  "interaction" : {
		"update_message" : 7
	},
  "doInteraction" : (state, userId, map) => { // tic-tac-toe example
	if state == nil {
		state = {
			"board": tictactoe.empty_board,
			"next": "X",
			"end": nil,
			"turn": 0
		}
	}
	clicked = map.custom_id
	if clicked == "reset" {
		InteractionRespond({
			"type": discord.interaction.update_message,
			"data": {"content": "<@" + userId + "> has reset the board", "components": tictactoe.boardToComponents(tictactoe.empty_board,-1,-1)}})
		return nil // clear state
	}
	if state.end != nil || state.turn >= 9 {
		InteractionRespond({"type": discord.interaction.update_message, "data": {"content": "Game is over <@" + userId + ">"}})
		return state
	}
	state.turn = state.turn + 1 // no ++ on map/indexes yet.
	tag = "<@" + userId + ">"
	if clicked == "play" {
		move = tictactoe.play(state.board, state.next)
		log("Move", move)
		i = move[0]
		j = move[1]
		clicked = str(i+1) + "," + str(j+1)
		tag = "Grol"
	} else {
		pair = split(clicked, ",")
		i=int(pair[0])-1
		j=int(pair[1])-1
	}
	if state.board[i][j] != "" {
		InteractionRespond({"type": discord.interaction.update_message, "data": {"content": clicked + " is already occupied"}})
		return state
	}
	board = state.board
	row = board[i]
	row[j] = state.next
	board[i] = row
	state.board = board
	state.next = tictactoe.next(state.next)
	state.end = tictactoe.endGame(board)
	if state.end != nil{
		clicked = clicked + ": " + state.end + " wins!"
	} else if state.turn >= 9 {
		clicked = clicked + ": draw."
	}
	InteractionRespond({
		"type": discord.interaction.update_message,
		"data": {"content": tag + " played " + clicked, "components": tictactoe.boardToComponents(state.board,i,j)}
	})
	state
  }
}

state = {}

// ---- tic tac toe ----


tictactoe = {
  "empty_board": [["","",""],["","",""],["","",""]],
  "boardToComponents": (board, hi, hj) => {
	walk((row,i) => {discord.actionRow(
		walk((cell,j) => {
		   if cell == "" {
			   cell = "\u200B" // zero width space
		   }
		   style = discord.buttonStyle.secondary
		   if i == hi && j == hj {
			   style = discord.buttonStyle.primary
		   }
		   discord.button(cell, style, sprintf("%d,%d", i+1, j+1))
		}, row))}, board) +
		[discord.actionRow([discord.button("Grol Play",discord.buttonStyle.success,"play"), discord.button("Reset", discord.buttonStyle.danger, "reset")])]
  },
  "sendBoard": board => {
	msg = {
		"content":    "Tic-Tac-Toe",
		"components": tictactoe.boardToComponents(board, -1, -1)
	}
	ChannelMessageSendComplex(msg)
    },
  "endGame": board => {
	// check for win
	for i=0:3 {
		if board[i][0] != "" && board[i][0] == board[i][1] && board[i][1] == board[i][2] {
			return board[i][0]
		} else if board[0][i] != "" && board[0][i] == board[1][i] && board[1][i] == board[2][i] {
			return board[0][i]
		}
	}
	if board[0][0] != "" && board[0][0] == board[1][1] && board[1][1] == board[2][2] {
		board[0][0]
	} else if board[0][2] != "" && board[0][2] == board[1][1] && board[1][1] == board[2][0] {
		board[0][2]
	} else {
		nil
	}
  },
  "next": cur => {
	if cur == "X" {
		"O"
	} else {
		"X"
	}
  },
  "try": (board, i, j, next) => {
	if board[i][j] != "" {
		return nil
	}
	row = board[i]
	row[j] = next
	board[i] = row
	return board
},
  "play": (board, next) => {
	freeList = []
	for i = 0:3 {
		for j = 0:3 {
			check = tictactoe.try(board, i, j, next)
			if check == nil {
				continue
			}
			freeList = freeList + [[i,j]]
			if tictactoe.endGame(check) != nil {
				log("Win by", next, "at", i, j)
				return [i,j]
			}
		}
	}
	log("no win yet", freeList)
	n = tictactoe.next(next)
	// No win, try to block
	for c = freeList {
		log("Checking", c)
		i = c[0]
		j = c[1]
		check = tictactoe.try(board, i, j, n)
		if tictactoe.endGame(check) != nil {
			log("Loss by", next, "at", i, j)
			return [i,j]
		}
	}
	if len(freeList) == 1 { // only one move left
		return freeList[0]
	}
	// try middle move
	if board[1][1] == "" {
		return [1,1]
	}
	// random move
	freeList[rand(len(freeList))]
  },
}

func TicTacToe() {
	tictactoe.sendBoard(tictactoe.empty_board)
}

// ------- Misc stuff ----

func layout(){
	println("Simple project layout [github.com/go-standard/project-layout](<https://github.com/go-standard/project-layout#project-layout>) - simple is good!")
}


// Result of eval of this file is logged by bot.go Run(). confirm we reached the end without error.
print("Imported discord grol library ok")
